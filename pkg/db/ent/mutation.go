// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"github.com/NpoolPlatform/cloud-hashing-order/pkg/db/ent/compensate"
	"github.com/NpoolPlatform/cloud-hashing-order/pkg/db/ent/gaspaying"
	"github.com/NpoolPlatform/cloud-hashing-order/pkg/db/ent/goodpaying"
	"github.com/NpoolPlatform/cloud-hashing-order/pkg/db/ent/order"
	"github.com/NpoolPlatform/cloud-hashing-order/pkg/db/ent/outofgas"
	"github.com/NpoolPlatform/cloud-hashing-order/pkg/db/ent/payment"
	"github.com/NpoolPlatform/cloud-hashing-order/pkg/db/ent/predicate"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCompensate = "Compensate"
	TypeGasPaying  = "GasPaying"
	TypeGoodPaying = "GoodPaying"
	TypeOrder      = "Order"
	TypeOutOfGas   = "OutOfGas"
	TypePayment    = "Payment"
)

// CompensateMutation represents an operation that mutates the Compensate nodes in the graph.
type CompensateMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	order_id      *uuid.UUID
	start         *uint32
	addstart      *int32
	end           *uint32
	addend        *int32
	message       *string
	create_at     *uint32
	addcreate_at  *int32
	update_at     *uint32
	addupdate_at  *int32
	delete_at     *uint32
	adddelete_at  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Compensate, error)
	predicates    []predicate.Compensate
}

var _ ent.Mutation = (*CompensateMutation)(nil)

// compensateOption allows management of the mutation configuration using functional options.
type compensateOption func(*CompensateMutation)

// newCompensateMutation creates new mutation for the Compensate entity.
func newCompensateMutation(c config, op Op, opts ...compensateOption) *CompensateMutation {
	m := &CompensateMutation{
		config:        c,
		op:            op,
		typ:           TypeCompensate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompensateID sets the ID field of the mutation.
func withCompensateID(id uuid.UUID) compensateOption {
	return func(m *CompensateMutation) {
		var (
			err   error
			once  sync.Once
			value *Compensate
		)
		m.oldValue = func(ctx context.Context) (*Compensate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Compensate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompensate sets the old Compensate of the mutation.
func withCompensate(node *Compensate) compensateOption {
	return func(m *CompensateMutation) {
		m.oldValue = func(context.Context) (*Compensate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompensateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompensateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Compensate entities.
func (m *CompensateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompensateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompensateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Compensate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *CompensateMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CompensateMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Compensate entity.
// If the Compensate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensateMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CompensateMutation) ResetOrderID() {
	m.order_id = nil
}

// SetStart sets the "start" field.
func (m *CompensateMutation) SetStart(u uint32) {
	m.start = &u
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *CompensateMutation) Start() (r uint32, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Compensate entity.
// If the Compensate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensateMutation) OldStart(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds u to the "start" field.
func (m *CompensateMutation) AddStart(u int32) {
	if m.addstart != nil {
		*m.addstart += u
	} else {
		m.addstart = &u
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *CompensateMutation) AddedStart() (r int32, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *CompensateMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *CompensateMutation) SetEnd(u uint32) {
	m.end = &u
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *CompensateMutation) End() (r uint32, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Compensate entity.
// If the Compensate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensateMutation) OldEnd(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds u to the "end" field.
func (m *CompensateMutation) AddEnd(u int32) {
	if m.addend != nil {
		*m.addend += u
	} else {
		m.addend = &u
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *CompensateMutation) AddedEnd() (r int32, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *CompensateMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetMessage sets the "message" field.
func (m *CompensateMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *CompensateMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Compensate entity.
// If the Compensate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensateMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *CompensateMutation) ResetMessage() {
	m.message = nil
}

// SetCreateAt sets the "create_at" field.
func (m *CompensateMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *CompensateMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the Compensate entity.
// If the Compensate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensateMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *CompensateMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *CompensateMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *CompensateMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *CompensateMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *CompensateMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the Compensate entity.
// If the Compensate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensateMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *CompensateMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *CompensateMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *CompensateMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *CompensateMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *CompensateMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the Compensate entity.
// If the Compensate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompensateMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *CompensateMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *CompensateMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *CompensateMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the CompensateMutation builder.
func (m *CompensateMutation) Where(ps ...predicate.Compensate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CompensateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Compensate).
func (m *CompensateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompensateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.order_id != nil {
		fields = append(fields, compensate.FieldOrderID)
	}
	if m.start != nil {
		fields = append(fields, compensate.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, compensate.FieldEnd)
	}
	if m.message != nil {
		fields = append(fields, compensate.FieldMessage)
	}
	if m.create_at != nil {
		fields = append(fields, compensate.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, compensate.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, compensate.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompensateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case compensate.FieldOrderID:
		return m.OrderID()
	case compensate.FieldStart:
		return m.Start()
	case compensate.FieldEnd:
		return m.End()
	case compensate.FieldMessage:
		return m.Message()
	case compensate.FieldCreateAt:
		return m.CreateAt()
	case compensate.FieldUpdateAt:
		return m.UpdateAt()
	case compensate.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompensateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case compensate.FieldOrderID:
		return m.OldOrderID(ctx)
	case compensate.FieldStart:
		return m.OldStart(ctx)
	case compensate.FieldEnd:
		return m.OldEnd(ctx)
	case compensate.FieldMessage:
		return m.OldMessage(ctx)
	case compensate.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case compensate.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case compensate.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown Compensate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompensateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case compensate.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case compensate.FieldStart:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case compensate.FieldEnd:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case compensate.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case compensate.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case compensate.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case compensate.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown Compensate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompensateMutation) AddedFields() []string {
	var fields []string
	if m.addstart != nil {
		fields = append(fields, compensate.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, compensate.FieldEnd)
	}
	if m.addcreate_at != nil {
		fields = append(fields, compensate.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, compensate.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, compensate.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompensateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case compensate.FieldStart:
		return m.AddedStart()
	case compensate.FieldEnd:
		return m.AddedEnd()
	case compensate.FieldCreateAt:
		return m.AddedCreateAt()
	case compensate.FieldUpdateAt:
		return m.AddedUpdateAt()
	case compensate.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompensateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case compensate.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case compensate.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	case compensate.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case compensate.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case compensate.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown Compensate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompensateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompensateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompensateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Compensate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompensateMutation) ResetField(name string) error {
	switch name {
	case compensate.FieldOrderID:
		m.ResetOrderID()
		return nil
	case compensate.FieldStart:
		m.ResetStart()
		return nil
	case compensate.FieldEnd:
		m.ResetEnd()
		return nil
	case compensate.FieldMessage:
		m.ResetMessage()
		return nil
	case compensate.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case compensate.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case compensate.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown Compensate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompensateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompensateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompensateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompensateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompensateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompensateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompensateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Compensate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompensateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Compensate edge %s", name)
}

// GasPayingMutation represents an operation that mutates the GasPaying nodes in the graph.
type GasPayingMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	order_id            *uuid.UUID
	fee_type_id         *uuid.UUID
	payment_id          *uuid.UUID
	duration_minutes    *uint32
	addduration_minutes *int32
	create_at           *uint32
	addcreate_at        *int32
	update_at           *uint32
	addupdate_at        *int32
	delete_at           *uint32
	adddelete_at        *int32
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*GasPaying, error)
	predicates          []predicate.GasPaying
}

var _ ent.Mutation = (*GasPayingMutation)(nil)

// gaspayingOption allows management of the mutation configuration using functional options.
type gaspayingOption func(*GasPayingMutation)

// newGasPayingMutation creates new mutation for the GasPaying entity.
func newGasPayingMutation(c config, op Op, opts ...gaspayingOption) *GasPayingMutation {
	m := &GasPayingMutation{
		config:        c,
		op:            op,
		typ:           TypeGasPaying,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGasPayingID sets the ID field of the mutation.
func withGasPayingID(id uuid.UUID) gaspayingOption {
	return func(m *GasPayingMutation) {
		var (
			err   error
			once  sync.Once
			value *GasPaying
		)
		m.oldValue = func(ctx context.Context) (*GasPaying, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GasPaying.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGasPaying sets the old GasPaying of the mutation.
func withGasPaying(node *GasPaying) gaspayingOption {
	return func(m *GasPayingMutation) {
		m.oldValue = func(context.Context) (*GasPaying, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GasPayingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GasPayingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GasPaying entities.
func (m *GasPayingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GasPayingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GasPayingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GasPaying.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *GasPayingMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *GasPayingMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the GasPaying entity.
// If the GasPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GasPayingMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *GasPayingMutation) ResetOrderID() {
	m.order_id = nil
}

// SetFeeTypeID sets the "fee_type_id" field.
func (m *GasPayingMutation) SetFeeTypeID(u uuid.UUID) {
	m.fee_type_id = &u
}

// FeeTypeID returns the value of the "fee_type_id" field in the mutation.
func (m *GasPayingMutation) FeeTypeID() (r uuid.UUID, exists bool) {
	v := m.fee_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFeeTypeID returns the old "fee_type_id" field's value of the GasPaying entity.
// If the GasPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GasPayingMutation) OldFeeTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeeTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeeTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeeTypeID: %w", err)
	}
	return oldValue.FeeTypeID, nil
}

// ResetFeeTypeID resets all changes to the "fee_type_id" field.
func (m *GasPayingMutation) ResetFeeTypeID() {
	m.fee_type_id = nil
}

// SetPaymentID sets the "payment_id" field.
func (m *GasPayingMutation) SetPaymentID(u uuid.UUID) {
	m.payment_id = &u
}

// PaymentID returns the value of the "payment_id" field in the mutation.
func (m *GasPayingMutation) PaymentID() (r uuid.UUID, exists bool) {
	v := m.payment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentID returns the old "payment_id" field's value of the GasPaying entity.
// If the GasPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GasPayingMutation) OldPaymentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentID: %w", err)
	}
	return oldValue.PaymentID, nil
}

// ResetPaymentID resets all changes to the "payment_id" field.
func (m *GasPayingMutation) ResetPaymentID() {
	m.payment_id = nil
}

// SetDurationMinutes sets the "duration_minutes" field.
func (m *GasPayingMutation) SetDurationMinutes(u uint32) {
	m.duration_minutes = &u
	m.addduration_minutes = nil
}

// DurationMinutes returns the value of the "duration_minutes" field in the mutation.
func (m *GasPayingMutation) DurationMinutes() (r uint32, exists bool) {
	v := m.duration_minutes
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMinutes returns the old "duration_minutes" field's value of the GasPaying entity.
// If the GasPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GasPayingMutation) OldDurationMinutes(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMinutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMinutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMinutes: %w", err)
	}
	return oldValue.DurationMinutes, nil
}

// AddDurationMinutes adds u to the "duration_minutes" field.
func (m *GasPayingMutation) AddDurationMinutes(u int32) {
	if m.addduration_minutes != nil {
		*m.addduration_minutes += u
	} else {
		m.addduration_minutes = &u
	}
}

// AddedDurationMinutes returns the value that was added to the "duration_minutes" field in this mutation.
func (m *GasPayingMutation) AddedDurationMinutes() (r int32, exists bool) {
	v := m.addduration_minutes
	if v == nil {
		return
	}
	return *v, true
}

// ResetDurationMinutes resets all changes to the "duration_minutes" field.
func (m *GasPayingMutation) ResetDurationMinutes() {
	m.duration_minutes = nil
	m.addduration_minutes = nil
}

// SetCreateAt sets the "create_at" field.
func (m *GasPayingMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *GasPayingMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the GasPaying entity.
// If the GasPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GasPayingMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *GasPayingMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *GasPayingMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *GasPayingMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *GasPayingMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *GasPayingMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the GasPaying entity.
// If the GasPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GasPayingMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *GasPayingMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *GasPayingMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *GasPayingMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *GasPayingMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *GasPayingMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the GasPaying entity.
// If the GasPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GasPayingMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *GasPayingMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *GasPayingMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *GasPayingMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the GasPayingMutation builder.
func (m *GasPayingMutation) Where(ps ...predicate.GasPaying) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GasPayingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GasPaying).
func (m *GasPayingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GasPayingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.order_id != nil {
		fields = append(fields, gaspaying.FieldOrderID)
	}
	if m.fee_type_id != nil {
		fields = append(fields, gaspaying.FieldFeeTypeID)
	}
	if m.payment_id != nil {
		fields = append(fields, gaspaying.FieldPaymentID)
	}
	if m.duration_minutes != nil {
		fields = append(fields, gaspaying.FieldDurationMinutes)
	}
	if m.create_at != nil {
		fields = append(fields, gaspaying.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, gaspaying.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, gaspaying.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GasPayingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gaspaying.FieldOrderID:
		return m.OrderID()
	case gaspaying.FieldFeeTypeID:
		return m.FeeTypeID()
	case gaspaying.FieldPaymentID:
		return m.PaymentID()
	case gaspaying.FieldDurationMinutes:
		return m.DurationMinutes()
	case gaspaying.FieldCreateAt:
		return m.CreateAt()
	case gaspaying.FieldUpdateAt:
		return m.UpdateAt()
	case gaspaying.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GasPayingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gaspaying.FieldOrderID:
		return m.OldOrderID(ctx)
	case gaspaying.FieldFeeTypeID:
		return m.OldFeeTypeID(ctx)
	case gaspaying.FieldPaymentID:
		return m.OldPaymentID(ctx)
	case gaspaying.FieldDurationMinutes:
		return m.OldDurationMinutes(ctx)
	case gaspaying.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case gaspaying.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case gaspaying.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown GasPaying field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GasPayingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gaspaying.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case gaspaying.FieldFeeTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeeTypeID(v)
		return nil
	case gaspaying.FieldPaymentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentID(v)
		return nil
	case gaspaying.FieldDurationMinutes:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMinutes(v)
		return nil
	case gaspaying.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case gaspaying.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case gaspaying.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown GasPaying field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GasPayingMutation) AddedFields() []string {
	var fields []string
	if m.addduration_minutes != nil {
		fields = append(fields, gaspaying.FieldDurationMinutes)
	}
	if m.addcreate_at != nil {
		fields = append(fields, gaspaying.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, gaspaying.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, gaspaying.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GasPayingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gaspaying.FieldDurationMinutes:
		return m.AddedDurationMinutes()
	case gaspaying.FieldCreateAt:
		return m.AddedCreateAt()
	case gaspaying.FieldUpdateAt:
		return m.AddedUpdateAt()
	case gaspaying.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GasPayingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gaspaying.FieldDurationMinutes:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMinutes(v)
		return nil
	case gaspaying.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case gaspaying.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case gaspaying.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown GasPaying numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GasPayingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GasPayingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GasPayingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GasPaying nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GasPayingMutation) ResetField(name string) error {
	switch name {
	case gaspaying.FieldOrderID:
		m.ResetOrderID()
		return nil
	case gaspaying.FieldFeeTypeID:
		m.ResetFeeTypeID()
		return nil
	case gaspaying.FieldPaymentID:
		m.ResetPaymentID()
		return nil
	case gaspaying.FieldDurationMinutes:
		m.ResetDurationMinutes()
		return nil
	case gaspaying.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case gaspaying.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case gaspaying.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown GasPaying field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GasPayingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GasPayingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GasPayingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GasPayingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GasPayingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GasPayingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GasPayingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GasPaying unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GasPayingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GasPaying edge %s", name)
}

// GoodPayingMutation represents an operation that mutates the GoodPaying nodes in the graph.
type GoodPayingMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	order_id      *uuid.UUID
	payment_id    *uuid.UUID
	create_at     *uint32
	addcreate_at  *int32
	update_at     *uint32
	addupdate_at  *int32
	delete_at     *uint32
	adddelete_at  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*GoodPaying, error)
	predicates    []predicate.GoodPaying
}

var _ ent.Mutation = (*GoodPayingMutation)(nil)

// goodpayingOption allows management of the mutation configuration using functional options.
type goodpayingOption func(*GoodPayingMutation)

// newGoodPayingMutation creates new mutation for the GoodPaying entity.
func newGoodPayingMutation(c config, op Op, opts ...goodpayingOption) *GoodPayingMutation {
	m := &GoodPayingMutation{
		config:        c,
		op:            op,
		typ:           TypeGoodPaying,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoodPayingID sets the ID field of the mutation.
func withGoodPayingID(id uuid.UUID) goodpayingOption {
	return func(m *GoodPayingMutation) {
		var (
			err   error
			once  sync.Once
			value *GoodPaying
		)
		m.oldValue = func(ctx context.Context) (*GoodPaying, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoodPaying.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoodPaying sets the old GoodPaying of the mutation.
func withGoodPaying(node *GoodPaying) goodpayingOption {
	return func(m *GoodPayingMutation) {
		m.oldValue = func(context.Context) (*GoodPaying, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoodPayingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoodPayingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoodPaying entities.
func (m *GoodPayingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoodPayingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoodPayingMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoodPaying.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *GoodPayingMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *GoodPayingMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the GoodPaying entity.
// If the GoodPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodPayingMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *GoodPayingMutation) ResetOrderID() {
	m.order_id = nil
}

// SetPaymentID sets the "payment_id" field.
func (m *GoodPayingMutation) SetPaymentID(u uuid.UUID) {
	m.payment_id = &u
}

// PaymentID returns the value of the "payment_id" field in the mutation.
func (m *GoodPayingMutation) PaymentID() (r uuid.UUID, exists bool) {
	v := m.payment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentID returns the old "payment_id" field's value of the GoodPaying entity.
// If the GoodPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodPayingMutation) OldPaymentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentID: %w", err)
	}
	return oldValue.PaymentID, nil
}

// ResetPaymentID resets all changes to the "payment_id" field.
func (m *GoodPayingMutation) ResetPaymentID() {
	m.payment_id = nil
}

// SetCreateAt sets the "create_at" field.
func (m *GoodPayingMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *GoodPayingMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the GoodPaying entity.
// If the GoodPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodPayingMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *GoodPayingMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *GoodPayingMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *GoodPayingMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *GoodPayingMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *GoodPayingMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the GoodPaying entity.
// If the GoodPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodPayingMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *GoodPayingMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *GoodPayingMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *GoodPayingMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *GoodPayingMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *GoodPayingMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the GoodPaying entity.
// If the GoodPaying object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoodPayingMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *GoodPayingMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *GoodPayingMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *GoodPayingMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the GoodPayingMutation builder.
func (m *GoodPayingMutation) Where(ps ...predicate.GoodPaying) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GoodPayingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GoodPaying).
func (m *GoodPayingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoodPayingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.order_id != nil {
		fields = append(fields, goodpaying.FieldOrderID)
	}
	if m.payment_id != nil {
		fields = append(fields, goodpaying.FieldPaymentID)
	}
	if m.create_at != nil {
		fields = append(fields, goodpaying.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, goodpaying.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, goodpaying.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoodPayingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case goodpaying.FieldOrderID:
		return m.OrderID()
	case goodpaying.FieldPaymentID:
		return m.PaymentID()
	case goodpaying.FieldCreateAt:
		return m.CreateAt()
	case goodpaying.FieldUpdateAt:
		return m.UpdateAt()
	case goodpaying.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoodPayingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case goodpaying.FieldOrderID:
		return m.OldOrderID(ctx)
	case goodpaying.FieldPaymentID:
		return m.OldPaymentID(ctx)
	case goodpaying.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case goodpaying.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case goodpaying.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown GoodPaying field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodPayingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case goodpaying.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case goodpaying.FieldPaymentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentID(v)
		return nil
	case goodpaying.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case goodpaying.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case goodpaying.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodPaying field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoodPayingMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_at != nil {
		fields = append(fields, goodpaying.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, goodpaying.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, goodpaying.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoodPayingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case goodpaying.FieldCreateAt:
		return m.AddedCreateAt()
	case goodpaying.FieldUpdateAt:
		return m.AddedUpdateAt()
	case goodpaying.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoodPayingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case goodpaying.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case goodpaying.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case goodpaying.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown GoodPaying numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoodPayingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoodPayingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoodPayingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GoodPaying nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoodPayingMutation) ResetField(name string) error {
	switch name {
	case goodpaying.FieldOrderID:
		m.ResetOrderID()
		return nil
	case goodpaying.FieldPaymentID:
		m.ResetPaymentID()
		return nil
	case goodpaying.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case goodpaying.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case goodpaying.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown GoodPaying field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoodPayingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoodPayingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoodPayingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoodPayingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoodPayingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoodPayingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoodPayingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GoodPaying unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoodPayingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GoodPaying edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	good_id                   *uuid.UUID
	app_id                    *uuid.UUID
	user_id                   *uuid.UUID
	parent_id                 *uuid.UUID
	units                     *uint32
	addunits                  *int32
	promotion_id              *uuid.UUID
	discount_coupon_id        *uuid.UUID
	user_special_reduction_id *uuid.UUID
	start                     *uint32
	addstart                  *int32
	end                       *uint32
	addend                    *int32
	coupon_id                 *uuid.UUID
	order_type                *string
	create_at                 *uint32
	addcreate_at              *int32
	update_at                 *uint32
	addupdate_at              *int32
	delete_at                 *uint32
	adddelete_at              *int32
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Order, error)
	predicates                []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id uuid.UUID) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGoodID sets the "good_id" field.
func (m *OrderMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *OrderMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *OrderMutation) ResetGoodID() {
	m.good_id = nil
}

// SetAppID sets the "app_id" field.
func (m *OrderMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *OrderMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *OrderMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *OrderMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderMutation) ResetUserID() {
	m.user_id = nil
}

// SetParentID sets the "parent_id" field.
func (m *OrderMutation) SetParentID(u uuid.UUID) {
	m.parent_id = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *OrderMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldParentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *OrderMutation) ClearParentID() {
	m.parent_id = nil
	m.clearedFields[order.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *OrderMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[order.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *OrderMutation) ResetParentID() {
	m.parent_id = nil
	delete(m.clearedFields, order.FieldParentID)
}

// SetUnits sets the "units" field.
func (m *OrderMutation) SetUnits(u uint32) {
	m.units = &u
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *OrderMutation) Units() (r uint32, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUnits(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds u to the "units" field.
func (m *OrderMutation) AddUnits(u int32) {
	if m.addunits != nil {
		*m.addunits += u
	} else {
		m.addunits = &u
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *OrderMutation) AddedUnits() (r int32, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnits resets all changes to the "units" field.
func (m *OrderMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
}

// SetPromotionID sets the "promotion_id" field.
func (m *OrderMutation) SetPromotionID(u uuid.UUID) {
	m.promotion_id = &u
}

// PromotionID returns the value of the "promotion_id" field in the mutation.
func (m *OrderMutation) PromotionID() (r uuid.UUID, exists bool) {
	v := m.promotion_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPromotionID returns the old "promotion_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPromotionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromotionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromotionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromotionID: %w", err)
	}
	return oldValue.PromotionID, nil
}

// ResetPromotionID resets all changes to the "promotion_id" field.
func (m *OrderMutation) ResetPromotionID() {
	m.promotion_id = nil
}

// SetDiscountCouponID sets the "discount_coupon_id" field.
func (m *OrderMutation) SetDiscountCouponID(u uuid.UUID) {
	m.discount_coupon_id = &u
}

// DiscountCouponID returns the value of the "discount_coupon_id" field in the mutation.
func (m *OrderMutation) DiscountCouponID() (r uuid.UUID, exists bool) {
	v := m.discount_coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountCouponID returns the old "discount_coupon_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDiscountCouponID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountCouponID: %w", err)
	}
	return oldValue.DiscountCouponID, nil
}

// ResetDiscountCouponID resets all changes to the "discount_coupon_id" field.
func (m *OrderMutation) ResetDiscountCouponID() {
	m.discount_coupon_id = nil
}

// SetUserSpecialReductionID sets the "user_special_reduction_id" field.
func (m *OrderMutation) SetUserSpecialReductionID(u uuid.UUID) {
	m.user_special_reduction_id = &u
}

// UserSpecialReductionID returns the value of the "user_special_reduction_id" field in the mutation.
func (m *OrderMutation) UserSpecialReductionID() (r uuid.UUID, exists bool) {
	v := m.user_special_reduction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSpecialReductionID returns the old "user_special_reduction_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserSpecialReductionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSpecialReductionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSpecialReductionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSpecialReductionID: %w", err)
	}
	return oldValue.UserSpecialReductionID, nil
}

// ResetUserSpecialReductionID resets all changes to the "user_special_reduction_id" field.
func (m *OrderMutation) ResetUserSpecialReductionID() {
	m.user_special_reduction_id = nil
}

// SetStart sets the "start" field.
func (m *OrderMutation) SetStart(u uint32) {
	m.start = &u
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *OrderMutation) Start() (r uint32, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStart(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds u to the "start" field.
func (m *OrderMutation) AddStart(u int32) {
	if m.addstart != nil {
		*m.addstart += u
	} else {
		m.addstart = &u
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *OrderMutation) AddedStart() (r int32, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *OrderMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *OrderMutation) SetEnd(u uint32) {
	m.end = &u
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *OrderMutation) End() (r uint32, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldEnd(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds u to the "end" field.
func (m *OrderMutation) AddEnd(u int32) {
	if m.addend != nil {
		*m.addend += u
	} else {
		m.addend = &u
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *OrderMutation) AddedEnd() (r int32, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *OrderMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetCouponID sets the "coupon_id" field.
func (m *OrderMutation) SetCouponID(u uuid.UUID) {
	m.coupon_id = &u
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *OrderMutation) CouponID() (r uuid.UUID, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCouponID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *OrderMutation) ResetCouponID() {
	m.coupon_id = nil
}

// SetOrderType sets the "order_type" field.
func (m *OrderMutation) SetOrderType(s string) {
	m.order_type = &s
}

// OrderType returns the value of the "order_type" field in the mutation.
func (m *OrderMutation) OrderType() (r string, exists bool) {
	v := m.order_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderType returns the old "order_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderType: %w", err)
	}
	return oldValue.OrderType, nil
}

// ResetOrderType resets all changes to the "order_type" field.
func (m *OrderMutation) ResetOrderType() {
	m.order_type = nil
}

// SetCreateAt sets the "create_at" field.
func (m *OrderMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *OrderMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *OrderMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *OrderMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *OrderMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *OrderMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *OrderMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *OrderMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *OrderMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *OrderMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *OrderMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *OrderMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *OrderMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *OrderMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *OrderMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.good_id != nil {
		fields = append(fields, order.FieldGoodID)
	}
	if m.app_id != nil {
		fields = append(fields, order.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.parent_id != nil {
		fields = append(fields, order.FieldParentID)
	}
	if m.units != nil {
		fields = append(fields, order.FieldUnits)
	}
	if m.promotion_id != nil {
		fields = append(fields, order.FieldPromotionID)
	}
	if m.discount_coupon_id != nil {
		fields = append(fields, order.FieldDiscountCouponID)
	}
	if m.user_special_reduction_id != nil {
		fields = append(fields, order.FieldUserSpecialReductionID)
	}
	if m.start != nil {
		fields = append(fields, order.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, order.FieldEnd)
	}
	if m.coupon_id != nil {
		fields = append(fields, order.FieldCouponID)
	}
	if m.order_type != nil {
		fields = append(fields, order.FieldOrderType)
	}
	if m.create_at != nil {
		fields = append(fields, order.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, order.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, order.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldGoodID:
		return m.GoodID()
	case order.FieldAppID:
		return m.AppID()
	case order.FieldUserID:
		return m.UserID()
	case order.FieldParentID:
		return m.ParentID()
	case order.FieldUnits:
		return m.Units()
	case order.FieldPromotionID:
		return m.PromotionID()
	case order.FieldDiscountCouponID:
		return m.DiscountCouponID()
	case order.FieldUserSpecialReductionID:
		return m.UserSpecialReductionID()
	case order.FieldStart:
		return m.Start()
	case order.FieldEnd:
		return m.End()
	case order.FieldCouponID:
		return m.CouponID()
	case order.FieldOrderType:
		return m.OrderType()
	case order.FieldCreateAt:
		return m.CreateAt()
	case order.FieldUpdateAt:
		return m.UpdateAt()
	case order.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldGoodID:
		return m.OldGoodID(ctx)
	case order.FieldAppID:
		return m.OldAppID(ctx)
	case order.FieldUserID:
		return m.OldUserID(ctx)
	case order.FieldParentID:
		return m.OldParentID(ctx)
	case order.FieldUnits:
		return m.OldUnits(ctx)
	case order.FieldPromotionID:
		return m.OldPromotionID(ctx)
	case order.FieldDiscountCouponID:
		return m.OldDiscountCouponID(ctx)
	case order.FieldUserSpecialReductionID:
		return m.OldUserSpecialReductionID(ctx)
	case order.FieldStart:
		return m.OldStart(ctx)
	case order.FieldEnd:
		return m.OldEnd(ctx)
	case order.FieldCouponID:
		return m.OldCouponID(ctx)
	case order.FieldOrderType:
		return m.OldOrderType(ctx)
	case order.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case order.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case order.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case order.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case order.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case order.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case order.FieldUnits:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case order.FieldPromotionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromotionID(v)
		return nil
	case order.FieldDiscountCouponID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountCouponID(v)
		return nil
	case order.FieldUserSpecialReductionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSpecialReductionID(v)
		return nil
	case order.FieldStart:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case order.FieldEnd:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case order.FieldCouponID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case order.FieldOrderType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderType(v)
		return nil
	case order.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case order.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case order.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addunits != nil {
		fields = append(fields, order.FieldUnits)
	}
	if m.addstart != nil {
		fields = append(fields, order.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, order.FieldEnd)
	}
	if m.addcreate_at != nil {
		fields = append(fields, order.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, order.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, order.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldUnits:
		return m.AddedUnits()
	case order.FieldStart:
		return m.AddedStart()
	case order.FieldEnd:
		return m.AddedEnd()
	case order.FieldCreateAt:
		return m.AddedCreateAt()
	case order.FieldUpdateAt:
		return m.AddedUpdateAt()
	case order.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldUnits:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	case order.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case order.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	case order.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case order.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case order.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldParentID) {
		fields = append(fields, order.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldGoodID:
		m.ResetGoodID()
		return nil
	case order.FieldAppID:
		m.ResetAppID()
		return nil
	case order.FieldUserID:
		m.ResetUserID()
		return nil
	case order.FieldParentID:
		m.ResetParentID()
		return nil
	case order.FieldUnits:
		m.ResetUnits()
		return nil
	case order.FieldPromotionID:
		m.ResetPromotionID()
		return nil
	case order.FieldDiscountCouponID:
		m.ResetDiscountCouponID()
		return nil
	case order.FieldUserSpecialReductionID:
		m.ResetUserSpecialReductionID()
		return nil
	case order.FieldStart:
		m.ResetStart()
		return nil
	case order.FieldEnd:
		m.ResetEnd()
		return nil
	case order.FieldCouponID:
		m.ResetCouponID()
		return nil
	case order.FieldOrderType:
		m.ResetOrderType()
		return nil
	case order.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case order.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case order.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Order edge %s", name)
}

// OutOfGasMutation represents an operation that mutates the OutOfGas nodes in the graph.
type OutOfGasMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	order_id      *uuid.UUID
	start         *uint32
	addstart      *int32
	end           *uint32
	addend        *int32
	create_at     *uint32
	addcreate_at  *int32
	update_at     *uint32
	addupdate_at  *int32
	delete_at     *uint32
	adddelete_at  *int32
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*OutOfGas, error)
	predicates    []predicate.OutOfGas
}

var _ ent.Mutation = (*OutOfGasMutation)(nil)

// outofgasOption allows management of the mutation configuration using functional options.
type outofgasOption func(*OutOfGasMutation)

// newOutOfGasMutation creates new mutation for the OutOfGas entity.
func newOutOfGasMutation(c config, op Op, opts ...outofgasOption) *OutOfGasMutation {
	m := &OutOfGasMutation{
		config:        c,
		op:            op,
		typ:           TypeOutOfGas,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutOfGasID sets the ID field of the mutation.
func withOutOfGasID(id uuid.UUID) outofgasOption {
	return func(m *OutOfGasMutation) {
		var (
			err   error
			once  sync.Once
			value *OutOfGas
		)
		m.oldValue = func(ctx context.Context) (*OutOfGas, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutOfGas.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutOfGas sets the old OutOfGas of the mutation.
func withOutOfGas(node *OutOfGas) outofgasOption {
	return func(m *OutOfGasMutation) {
		m.oldValue = func(context.Context) (*OutOfGas, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutOfGasMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutOfGasMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OutOfGas entities.
func (m *OutOfGasMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutOfGasMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutOfGasMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutOfGas.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *OutOfGasMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OutOfGasMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OutOfGas entity.
// If the OutOfGas object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutOfGasMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OutOfGasMutation) ResetOrderID() {
	m.order_id = nil
}

// SetStart sets the "start" field.
func (m *OutOfGasMutation) SetStart(u uint32) {
	m.start = &u
	m.addstart = nil
}

// Start returns the value of the "start" field in the mutation.
func (m *OutOfGasMutation) Start() (r uint32, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the OutOfGas entity.
// If the OutOfGas object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutOfGasMutation) OldStart(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// AddStart adds u to the "start" field.
func (m *OutOfGasMutation) AddStart(u int32) {
	if m.addstart != nil {
		*m.addstart += u
	} else {
		m.addstart = &u
	}
}

// AddedStart returns the value that was added to the "start" field in this mutation.
func (m *OutOfGasMutation) AddedStart() (r int32, exists bool) {
	v := m.addstart
	if v == nil {
		return
	}
	return *v, true
}

// ResetStart resets all changes to the "start" field.
func (m *OutOfGasMutation) ResetStart() {
	m.start = nil
	m.addstart = nil
}

// SetEnd sets the "end" field.
func (m *OutOfGasMutation) SetEnd(u uint32) {
	m.end = &u
	m.addend = nil
}

// End returns the value of the "end" field in the mutation.
func (m *OutOfGasMutation) End() (r uint32, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the OutOfGas entity.
// If the OutOfGas object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutOfGasMutation) OldEnd(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// AddEnd adds u to the "end" field.
func (m *OutOfGasMutation) AddEnd(u int32) {
	if m.addend != nil {
		*m.addend += u
	} else {
		m.addend = &u
	}
}

// AddedEnd returns the value that was added to the "end" field in this mutation.
func (m *OutOfGasMutation) AddedEnd() (r int32, exists bool) {
	v := m.addend
	if v == nil {
		return
	}
	return *v, true
}

// ResetEnd resets all changes to the "end" field.
func (m *OutOfGasMutation) ResetEnd() {
	m.end = nil
	m.addend = nil
}

// SetCreateAt sets the "create_at" field.
func (m *OutOfGasMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *OutOfGasMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the OutOfGas entity.
// If the OutOfGas object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutOfGasMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *OutOfGasMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *OutOfGasMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *OutOfGasMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *OutOfGasMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *OutOfGasMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the OutOfGas entity.
// If the OutOfGas object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutOfGasMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *OutOfGasMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *OutOfGasMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *OutOfGasMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *OutOfGasMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *OutOfGasMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the OutOfGas entity.
// If the OutOfGas object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutOfGasMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *OutOfGasMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *OutOfGasMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *OutOfGasMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the OutOfGasMutation builder.
func (m *OutOfGasMutation) Where(ps ...predicate.OutOfGas) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutOfGasMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutOfGas).
func (m *OutOfGasMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutOfGasMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.order_id != nil {
		fields = append(fields, outofgas.FieldOrderID)
	}
	if m.start != nil {
		fields = append(fields, outofgas.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, outofgas.FieldEnd)
	}
	if m.create_at != nil {
		fields = append(fields, outofgas.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, outofgas.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, outofgas.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutOfGasMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outofgas.FieldOrderID:
		return m.OrderID()
	case outofgas.FieldStart:
		return m.Start()
	case outofgas.FieldEnd:
		return m.End()
	case outofgas.FieldCreateAt:
		return m.CreateAt()
	case outofgas.FieldUpdateAt:
		return m.UpdateAt()
	case outofgas.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutOfGasMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outofgas.FieldOrderID:
		return m.OldOrderID(ctx)
	case outofgas.FieldStart:
		return m.OldStart(ctx)
	case outofgas.FieldEnd:
		return m.OldEnd(ctx)
	case outofgas.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case outofgas.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case outofgas.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown OutOfGas field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutOfGasMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outofgas.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case outofgas.FieldStart:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case outofgas.FieldEnd:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case outofgas.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case outofgas.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case outofgas.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown OutOfGas field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutOfGasMutation) AddedFields() []string {
	var fields []string
	if m.addstart != nil {
		fields = append(fields, outofgas.FieldStart)
	}
	if m.addend != nil {
		fields = append(fields, outofgas.FieldEnd)
	}
	if m.addcreate_at != nil {
		fields = append(fields, outofgas.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, outofgas.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, outofgas.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutOfGasMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case outofgas.FieldStart:
		return m.AddedStart()
	case outofgas.FieldEnd:
		return m.AddedEnd()
	case outofgas.FieldCreateAt:
		return m.AddedCreateAt()
	case outofgas.FieldUpdateAt:
		return m.AddedUpdateAt()
	case outofgas.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutOfGasMutation) AddField(name string, value ent.Value) error {
	switch name {
	case outofgas.FieldStart:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStart(v)
		return nil
	case outofgas.FieldEnd:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEnd(v)
		return nil
	case outofgas.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case outofgas.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case outofgas.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown OutOfGas numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutOfGasMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutOfGasMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutOfGasMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutOfGas nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutOfGasMutation) ResetField(name string) error {
	switch name {
	case outofgas.FieldOrderID:
		m.ResetOrderID()
		return nil
	case outofgas.FieldStart:
		m.ResetStart()
		return nil
	case outofgas.FieldEnd:
		m.ResetEnd()
		return nil
	case outofgas.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case outofgas.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case outofgas.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown OutOfGas field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutOfGasMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutOfGasMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutOfGasMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutOfGasMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutOfGasMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutOfGasMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutOfGasMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OutOfGas unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutOfGasMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OutOfGas edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	app_id                     *uuid.UUID
	user_id                    *uuid.UUID
	good_id                    *uuid.UUID
	order_id                   *uuid.UUID
	account_id                 *uuid.UUID
	start_amount               *uint64
	addstart_amount            *int64
	amount                     *uint64
	addamount                  *int64
	pay_with_balance_amount    *decimal.Decimal
	addpay_with_balance_amount *decimal.Decimal
	finish_amount              *uint64
	addfinish_amount           *int64
	coin_usd_currency          *uint64
	addcoin_usd_currency       *int64
	local_coin_usd_currency    *uint64
	addlocal_coin_usd_currency *int64
	live_coin_usd_currency     *uint64
	addlive_coin_usd_currency  *int64
	coin_info_id               *uuid.UUID
	state                      *payment.State
	chain_transaction_id       *string
	platform_transaction_id    *uuid.UUID
	user_set_paid              *bool
	user_set_canceled          *bool
	user_payment_txid          *string
	fake_payment               *bool
	create_at                  *uint32
	addcreate_at               *int32
	update_at                  *uint32
	addupdate_at               *int32
	delete_at                  *uint32
	adddelete_at               *int32
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Payment, error)
	predicates                 []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id uuid.UUID) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payment entities.
func (m *PaymentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *PaymentMutation) SetAppID(u uuid.UUID) {
	m.app_id = &u
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PaymentMutation) AppID() (r uuid.UUID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAppID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PaymentMutation) ResetAppID() {
	m.app_id = nil
}

// SetUserID sets the "user_id" field.
func (m *PaymentMutation) SetUserID(u uuid.UUID) {
	m.user_id = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PaymentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PaymentMutation) ResetUserID() {
	m.user_id = nil
}

// SetGoodID sets the "good_id" field.
func (m *PaymentMutation) SetGoodID(u uuid.UUID) {
	m.good_id = &u
}

// GoodID returns the value of the "good_id" field in the mutation.
func (m *PaymentMutation) GoodID() (r uuid.UUID, exists bool) {
	v := m.good_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGoodID returns the old "good_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldGoodID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoodID: %w", err)
	}
	return oldValue.GoodID, nil
}

// ResetGoodID resets all changes to the "good_id" field.
func (m *PaymentMutation) ResetGoodID() {
	m.good_id = nil
}

// SetOrderID sets the "order_id" field.
func (m *PaymentMutation) SetOrderID(u uuid.UUID) {
	m.order_id = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *PaymentMutation) OrderID() (r uuid.UUID, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldOrderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *PaymentMutation) ResetOrderID() {
	m.order_id = nil
}

// SetAccountID sets the "account_id" field.
func (m *PaymentMutation) SetAccountID(u uuid.UUID) {
	m.account_id = &u
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *PaymentMutation) AccountID() (r uuid.UUID, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAccountID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *PaymentMutation) ResetAccountID() {
	m.account_id = nil
}

// SetStartAmount sets the "start_amount" field.
func (m *PaymentMutation) SetStartAmount(u uint64) {
	m.start_amount = &u
	m.addstart_amount = nil
}

// StartAmount returns the value of the "start_amount" field in the mutation.
func (m *PaymentMutation) StartAmount() (r uint64, exists bool) {
	v := m.start_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAmount returns the old "start_amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldStartAmount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAmount: %w", err)
	}
	return oldValue.StartAmount, nil
}

// AddStartAmount adds u to the "start_amount" field.
func (m *PaymentMutation) AddStartAmount(u int64) {
	if m.addstart_amount != nil {
		*m.addstart_amount += u
	} else {
		m.addstart_amount = &u
	}
}

// AddedStartAmount returns the value that was added to the "start_amount" field in this mutation.
func (m *PaymentMutation) AddedStartAmount() (r int64, exists bool) {
	v := m.addstart_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartAmount resets all changes to the "start_amount" field.
func (m *PaymentMutation) ResetStartAmount() {
	m.start_amount = nil
	m.addstart_amount = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentMutation) SetAmount(u uint64) {
	m.amount = &u
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentMutation) Amount() (r uint64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAmount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds u to the "amount" field.
func (m *PaymentMutation) AddAmount(u int64) {
	if m.addamount != nil {
		*m.addamount += u
	} else {
		m.addamount = &u
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentMutation) AddedAmount() (r int64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPayWithBalanceAmount sets the "pay_with_balance_amount" field.
func (m *PaymentMutation) SetPayWithBalanceAmount(d decimal.Decimal) {
	m.pay_with_balance_amount = &d
	m.addpay_with_balance_amount = nil
}

// PayWithBalanceAmount returns the value of the "pay_with_balance_amount" field in the mutation.
func (m *PaymentMutation) PayWithBalanceAmount() (r decimal.Decimal, exists bool) {
	v := m.pay_with_balance_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPayWithBalanceAmount returns the old "pay_with_balance_amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldPayWithBalanceAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayWithBalanceAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayWithBalanceAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayWithBalanceAmount: %w", err)
	}
	return oldValue.PayWithBalanceAmount, nil
}

// AddPayWithBalanceAmount adds d to the "pay_with_balance_amount" field.
func (m *PaymentMutation) AddPayWithBalanceAmount(d decimal.Decimal) {
	if m.addpay_with_balance_amount != nil {
		*m.addpay_with_balance_amount = m.addpay_with_balance_amount.Add(d)
	} else {
		m.addpay_with_balance_amount = &d
	}
}

// AddedPayWithBalanceAmount returns the value that was added to the "pay_with_balance_amount" field in this mutation.
func (m *PaymentMutation) AddedPayWithBalanceAmount() (r decimal.Decimal, exists bool) {
	v := m.addpay_with_balance_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayWithBalanceAmount clears the value of the "pay_with_balance_amount" field.
func (m *PaymentMutation) ClearPayWithBalanceAmount() {
	m.pay_with_balance_amount = nil
	m.addpay_with_balance_amount = nil
	m.clearedFields[payment.FieldPayWithBalanceAmount] = struct{}{}
}

// PayWithBalanceAmountCleared returns if the "pay_with_balance_amount" field was cleared in this mutation.
func (m *PaymentMutation) PayWithBalanceAmountCleared() bool {
	_, ok := m.clearedFields[payment.FieldPayWithBalanceAmount]
	return ok
}

// ResetPayWithBalanceAmount resets all changes to the "pay_with_balance_amount" field.
func (m *PaymentMutation) ResetPayWithBalanceAmount() {
	m.pay_with_balance_amount = nil
	m.addpay_with_balance_amount = nil
	delete(m.clearedFields, payment.FieldPayWithBalanceAmount)
}

// SetFinishAmount sets the "finish_amount" field.
func (m *PaymentMutation) SetFinishAmount(u uint64) {
	m.finish_amount = &u
	m.addfinish_amount = nil
}

// FinishAmount returns the value of the "finish_amount" field in the mutation.
func (m *PaymentMutation) FinishAmount() (r uint64, exists bool) {
	v := m.finish_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishAmount returns the old "finish_amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldFinishAmount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishAmount: %w", err)
	}
	return oldValue.FinishAmount, nil
}

// AddFinishAmount adds u to the "finish_amount" field.
func (m *PaymentMutation) AddFinishAmount(u int64) {
	if m.addfinish_amount != nil {
		*m.addfinish_amount += u
	} else {
		m.addfinish_amount = &u
	}
}

// AddedFinishAmount returns the value that was added to the "finish_amount" field in this mutation.
func (m *PaymentMutation) AddedFinishAmount() (r int64, exists bool) {
	v := m.addfinish_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetFinishAmount resets all changes to the "finish_amount" field.
func (m *PaymentMutation) ResetFinishAmount() {
	m.finish_amount = nil
	m.addfinish_amount = nil
}

// SetCoinUsdCurrency sets the "coin_usd_currency" field.
func (m *PaymentMutation) SetCoinUsdCurrency(u uint64) {
	m.coin_usd_currency = &u
	m.addcoin_usd_currency = nil
}

// CoinUsdCurrency returns the value of the "coin_usd_currency" field in the mutation.
func (m *PaymentMutation) CoinUsdCurrency() (r uint64, exists bool) {
	v := m.coin_usd_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinUsdCurrency returns the old "coin_usd_currency" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCoinUsdCurrency(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinUsdCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinUsdCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinUsdCurrency: %w", err)
	}
	return oldValue.CoinUsdCurrency, nil
}

// AddCoinUsdCurrency adds u to the "coin_usd_currency" field.
func (m *PaymentMutation) AddCoinUsdCurrency(u int64) {
	if m.addcoin_usd_currency != nil {
		*m.addcoin_usd_currency += u
	} else {
		m.addcoin_usd_currency = &u
	}
}

// AddedCoinUsdCurrency returns the value that was added to the "coin_usd_currency" field in this mutation.
func (m *PaymentMutation) AddedCoinUsdCurrency() (r int64, exists bool) {
	v := m.addcoin_usd_currency
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoinUsdCurrency resets all changes to the "coin_usd_currency" field.
func (m *PaymentMutation) ResetCoinUsdCurrency() {
	m.coin_usd_currency = nil
	m.addcoin_usd_currency = nil
}

// SetLocalCoinUsdCurrency sets the "local_coin_usd_currency" field.
func (m *PaymentMutation) SetLocalCoinUsdCurrency(u uint64) {
	m.local_coin_usd_currency = &u
	m.addlocal_coin_usd_currency = nil
}

// LocalCoinUsdCurrency returns the value of the "local_coin_usd_currency" field in the mutation.
func (m *PaymentMutation) LocalCoinUsdCurrency() (r uint64, exists bool) {
	v := m.local_coin_usd_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalCoinUsdCurrency returns the old "local_coin_usd_currency" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldLocalCoinUsdCurrency(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalCoinUsdCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalCoinUsdCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalCoinUsdCurrency: %w", err)
	}
	return oldValue.LocalCoinUsdCurrency, nil
}

// AddLocalCoinUsdCurrency adds u to the "local_coin_usd_currency" field.
func (m *PaymentMutation) AddLocalCoinUsdCurrency(u int64) {
	if m.addlocal_coin_usd_currency != nil {
		*m.addlocal_coin_usd_currency += u
	} else {
		m.addlocal_coin_usd_currency = &u
	}
}

// AddedLocalCoinUsdCurrency returns the value that was added to the "local_coin_usd_currency" field in this mutation.
func (m *PaymentMutation) AddedLocalCoinUsdCurrency() (r int64, exists bool) {
	v := m.addlocal_coin_usd_currency
	if v == nil {
		return
	}
	return *v, true
}

// ResetLocalCoinUsdCurrency resets all changes to the "local_coin_usd_currency" field.
func (m *PaymentMutation) ResetLocalCoinUsdCurrency() {
	m.local_coin_usd_currency = nil
	m.addlocal_coin_usd_currency = nil
}

// SetLiveCoinUsdCurrency sets the "live_coin_usd_currency" field.
func (m *PaymentMutation) SetLiveCoinUsdCurrency(u uint64) {
	m.live_coin_usd_currency = &u
	m.addlive_coin_usd_currency = nil
}

// LiveCoinUsdCurrency returns the value of the "live_coin_usd_currency" field in the mutation.
func (m *PaymentMutation) LiveCoinUsdCurrency() (r uint64, exists bool) {
	v := m.live_coin_usd_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldLiveCoinUsdCurrency returns the old "live_coin_usd_currency" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldLiveCoinUsdCurrency(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLiveCoinUsdCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLiveCoinUsdCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiveCoinUsdCurrency: %w", err)
	}
	return oldValue.LiveCoinUsdCurrency, nil
}

// AddLiveCoinUsdCurrency adds u to the "live_coin_usd_currency" field.
func (m *PaymentMutation) AddLiveCoinUsdCurrency(u int64) {
	if m.addlive_coin_usd_currency != nil {
		*m.addlive_coin_usd_currency += u
	} else {
		m.addlive_coin_usd_currency = &u
	}
}

// AddedLiveCoinUsdCurrency returns the value that was added to the "live_coin_usd_currency" field in this mutation.
func (m *PaymentMutation) AddedLiveCoinUsdCurrency() (r int64, exists bool) {
	v := m.addlive_coin_usd_currency
	if v == nil {
		return
	}
	return *v, true
}

// ResetLiveCoinUsdCurrency resets all changes to the "live_coin_usd_currency" field.
func (m *PaymentMutation) ResetLiveCoinUsdCurrency() {
	m.live_coin_usd_currency = nil
	m.addlive_coin_usd_currency = nil
}

// SetCoinInfoID sets the "coin_info_id" field.
func (m *PaymentMutation) SetCoinInfoID(u uuid.UUID) {
	m.coin_info_id = &u
}

// CoinInfoID returns the value of the "coin_info_id" field in the mutation.
func (m *PaymentMutation) CoinInfoID() (r uuid.UUID, exists bool) {
	v := m.coin_info_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoinInfoID returns the old "coin_info_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCoinInfoID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoinInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoinInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoinInfoID: %w", err)
	}
	return oldValue.CoinInfoID, nil
}

// ResetCoinInfoID resets all changes to the "coin_info_id" field.
func (m *PaymentMutation) ResetCoinInfoID() {
	m.coin_info_id = nil
}

// SetState sets the "state" field.
func (m *PaymentMutation) SetState(pa payment.State) {
	m.state = &pa
}

// State returns the value of the "state" field in the mutation.
func (m *PaymentMutation) State() (r payment.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldState(ctx context.Context) (v payment.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *PaymentMutation) ResetState() {
	m.state = nil
}

// SetChainTransactionID sets the "chain_transaction_id" field.
func (m *PaymentMutation) SetChainTransactionID(s string) {
	m.chain_transaction_id = &s
}

// ChainTransactionID returns the value of the "chain_transaction_id" field in the mutation.
func (m *PaymentMutation) ChainTransactionID() (r string, exists bool) {
	v := m.chain_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChainTransactionID returns the old "chain_transaction_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldChainTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChainTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChainTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChainTransactionID: %w", err)
	}
	return oldValue.ChainTransactionID, nil
}

// ResetChainTransactionID resets all changes to the "chain_transaction_id" field.
func (m *PaymentMutation) ResetChainTransactionID() {
	m.chain_transaction_id = nil
}

// SetPlatformTransactionID sets the "platform_transaction_id" field.
func (m *PaymentMutation) SetPlatformTransactionID(u uuid.UUID) {
	m.platform_transaction_id = &u
}

// PlatformTransactionID returns the value of the "platform_transaction_id" field in the mutation.
func (m *PaymentMutation) PlatformTransactionID() (r uuid.UUID, exists bool) {
	v := m.platform_transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformTransactionID returns the old "platform_transaction_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldPlatformTransactionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformTransactionID: %w", err)
	}
	return oldValue.PlatformTransactionID, nil
}

// ResetPlatformTransactionID resets all changes to the "platform_transaction_id" field.
func (m *PaymentMutation) ResetPlatformTransactionID() {
	m.platform_transaction_id = nil
}

// SetUserSetPaid sets the "user_set_paid" field.
func (m *PaymentMutation) SetUserSetPaid(b bool) {
	m.user_set_paid = &b
}

// UserSetPaid returns the value of the "user_set_paid" field in the mutation.
func (m *PaymentMutation) UserSetPaid() (r bool, exists bool) {
	v := m.user_set_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSetPaid returns the old "user_set_paid" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUserSetPaid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSetPaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSetPaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSetPaid: %w", err)
	}
	return oldValue.UserSetPaid, nil
}

// ResetUserSetPaid resets all changes to the "user_set_paid" field.
func (m *PaymentMutation) ResetUserSetPaid() {
	m.user_set_paid = nil
}

// SetUserSetCanceled sets the "user_set_canceled" field.
func (m *PaymentMutation) SetUserSetCanceled(b bool) {
	m.user_set_canceled = &b
}

// UserSetCanceled returns the value of the "user_set_canceled" field in the mutation.
func (m *PaymentMutation) UserSetCanceled() (r bool, exists bool) {
	v := m.user_set_canceled
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSetCanceled returns the old "user_set_canceled" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUserSetCanceled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSetCanceled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSetCanceled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSetCanceled: %w", err)
	}
	return oldValue.UserSetCanceled, nil
}

// ResetUserSetCanceled resets all changes to the "user_set_canceled" field.
func (m *PaymentMutation) ResetUserSetCanceled() {
	m.user_set_canceled = nil
}

// SetUserPaymentTxid sets the "user_payment_txid" field.
func (m *PaymentMutation) SetUserPaymentTxid(s string) {
	m.user_payment_txid = &s
}

// UserPaymentTxid returns the value of the "user_payment_txid" field in the mutation.
func (m *PaymentMutation) UserPaymentTxid() (r string, exists bool) {
	v := m.user_payment_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldUserPaymentTxid returns the old "user_payment_txid" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUserPaymentTxid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserPaymentTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserPaymentTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserPaymentTxid: %w", err)
	}
	return oldValue.UserPaymentTxid, nil
}

// ResetUserPaymentTxid resets all changes to the "user_payment_txid" field.
func (m *PaymentMutation) ResetUserPaymentTxid() {
	m.user_payment_txid = nil
}

// SetFakePayment sets the "fake_payment" field.
func (m *PaymentMutation) SetFakePayment(b bool) {
	m.fake_payment = &b
}

// FakePayment returns the value of the "fake_payment" field in the mutation.
func (m *PaymentMutation) FakePayment() (r bool, exists bool) {
	v := m.fake_payment
	if v == nil {
		return
	}
	return *v, true
}

// OldFakePayment returns the old "fake_payment" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldFakePayment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFakePayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFakePayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFakePayment: %w", err)
	}
	return oldValue.FakePayment, nil
}

// ResetFakePayment resets all changes to the "fake_payment" field.
func (m *PaymentMutation) ResetFakePayment() {
	m.fake_payment = nil
}

// SetCreateAt sets the "create_at" field.
func (m *PaymentMutation) SetCreateAt(u uint32) {
	m.create_at = &u
	m.addcreate_at = nil
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *PaymentMutation) CreateAt() (r uint32, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// AddCreateAt adds u to the "create_at" field.
func (m *PaymentMutation) AddCreateAt(u int32) {
	if m.addcreate_at != nil {
		*m.addcreate_at += u
	} else {
		m.addcreate_at = &u
	}
}

// AddedCreateAt returns the value that was added to the "create_at" field in this mutation.
func (m *PaymentMutation) AddedCreateAt() (r int32, exists bool) {
	v := m.addcreate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *PaymentMutation) ResetCreateAt() {
	m.create_at = nil
	m.addcreate_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *PaymentMutation) SetUpdateAt(u uint32) {
	m.update_at = &u
	m.addupdate_at = nil
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *PaymentMutation) UpdateAt() (r uint32, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUpdateAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// AddUpdateAt adds u to the "update_at" field.
func (m *PaymentMutation) AddUpdateAt(u int32) {
	if m.addupdate_at != nil {
		*m.addupdate_at += u
	} else {
		m.addupdate_at = &u
	}
}

// AddedUpdateAt returns the value that was added to the "update_at" field in this mutation.
func (m *PaymentMutation) AddedUpdateAt() (r int32, exists bool) {
	v := m.addupdate_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *PaymentMutation) ResetUpdateAt() {
	m.update_at = nil
	m.addupdate_at = nil
}

// SetDeleteAt sets the "delete_at" field.
func (m *PaymentMutation) SetDeleteAt(u uint32) {
	m.delete_at = &u
	m.adddelete_at = nil
}

// DeleteAt returns the value of the "delete_at" field in the mutation.
func (m *PaymentMutation) DeleteAt() (r uint32, exists bool) {
	v := m.delete_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteAt returns the old "delete_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldDeleteAt(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteAt: %w", err)
	}
	return oldValue.DeleteAt, nil
}

// AddDeleteAt adds u to the "delete_at" field.
func (m *PaymentMutation) AddDeleteAt(u int32) {
	if m.adddelete_at != nil {
		*m.adddelete_at += u
	} else {
		m.adddelete_at = &u
	}
}

// AddedDeleteAt returns the value that was added to the "delete_at" field in this mutation.
func (m *PaymentMutation) AddedDeleteAt() (r int32, exists bool) {
	v := m.adddelete_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleteAt resets all changes to the "delete_at" field.
func (m *PaymentMutation) ResetDeleteAt() {
	m.delete_at = nil
	m.adddelete_at = nil
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.app_id != nil {
		fields = append(fields, payment.FieldAppID)
	}
	if m.user_id != nil {
		fields = append(fields, payment.FieldUserID)
	}
	if m.good_id != nil {
		fields = append(fields, payment.FieldGoodID)
	}
	if m.order_id != nil {
		fields = append(fields, payment.FieldOrderID)
	}
	if m.account_id != nil {
		fields = append(fields, payment.FieldAccountID)
	}
	if m.start_amount != nil {
		fields = append(fields, payment.FieldStartAmount)
	}
	if m.amount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.pay_with_balance_amount != nil {
		fields = append(fields, payment.FieldPayWithBalanceAmount)
	}
	if m.finish_amount != nil {
		fields = append(fields, payment.FieldFinishAmount)
	}
	if m.coin_usd_currency != nil {
		fields = append(fields, payment.FieldCoinUsdCurrency)
	}
	if m.local_coin_usd_currency != nil {
		fields = append(fields, payment.FieldLocalCoinUsdCurrency)
	}
	if m.live_coin_usd_currency != nil {
		fields = append(fields, payment.FieldLiveCoinUsdCurrency)
	}
	if m.coin_info_id != nil {
		fields = append(fields, payment.FieldCoinInfoID)
	}
	if m.state != nil {
		fields = append(fields, payment.FieldState)
	}
	if m.chain_transaction_id != nil {
		fields = append(fields, payment.FieldChainTransactionID)
	}
	if m.platform_transaction_id != nil {
		fields = append(fields, payment.FieldPlatformTransactionID)
	}
	if m.user_set_paid != nil {
		fields = append(fields, payment.FieldUserSetPaid)
	}
	if m.user_set_canceled != nil {
		fields = append(fields, payment.FieldUserSetCanceled)
	}
	if m.user_payment_txid != nil {
		fields = append(fields, payment.FieldUserPaymentTxid)
	}
	if m.fake_payment != nil {
		fields = append(fields, payment.FieldFakePayment)
	}
	if m.create_at != nil {
		fields = append(fields, payment.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, payment.FieldUpdateAt)
	}
	if m.delete_at != nil {
		fields = append(fields, payment.FieldDeleteAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAppID:
		return m.AppID()
	case payment.FieldUserID:
		return m.UserID()
	case payment.FieldGoodID:
		return m.GoodID()
	case payment.FieldOrderID:
		return m.OrderID()
	case payment.FieldAccountID:
		return m.AccountID()
	case payment.FieldStartAmount:
		return m.StartAmount()
	case payment.FieldAmount:
		return m.Amount()
	case payment.FieldPayWithBalanceAmount:
		return m.PayWithBalanceAmount()
	case payment.FieldFinishAmount:
		return m.FinishAmount()
	case payment.FieldCoinUsdCurrency:
		return m.CoinUsdCurrency()
	case payment.FieldLocalCoinUsdCurrency:
		return m.LocalCoinUsdCurrency()
	case payment.FieldLiveCoinUsdCurrency:
		return m.LiveCoinUsdCurrency()
	case payment.FieldCoinInfoID:
		return m.CoinInfoID()
	case payment.FieldState:
		return m.State()
	case payment.FieldChainTransactionID:
		return m.ChainTransactionID()
	case payment.FieldPlatformTransactionID:
		return m.PlatformTransactionID()
	case payment.FieldUserSetPaid:
		return m.UserSetPaid()
	case payment.FieldUserSetCanceled:
		return m.UserSetCanceled()
	case payment.FieldUserPaymentTxid:
		return m.UserPaymentTxid()
	case payment.FieldFakePayment:
		return m.FakePayment()
	case payment.FieldCreateAt:
		return m.CreateAt()
	case payment.FieldUpdateAt:
		return m.UpdateAt()
	case payment.FieldDeleteAt:
		return m.DeleteAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldAppID:
		return m.OldAppID(ctx)
	case payment.FieldUserID:
		return m.OldUserID(ctx)
	case payment.FieldGoodID:
		return m.OldGoodID(ctx)
	case payment.FieldOrderID:
		return m.OldOrderID(ctx)
	case payment.FieldAccountID:
		return m.OldAccountID(ctx)
	case payment.FieldStartAmount:
		return m.OldStartAmount(ctx)
	case payment.FieldAmount:
		return m.OldAmount(ctx)
	case payment.FieldPayWithBalanceAmount:
		return m.OldPayWithBalanceAmount(ctx)
	case payment.FieldFinishAmount:
		return m.OldFinishAmount(ctx)
	case payment.FieldCoinUsdCurrency:
		return m.OldCoinUsdCurrency(ctx)
	case payment.FieldLocalCoinUsdCurrency:
		return m.OldLocalCoinUsdCurrency(ctx)
	case payment.FieldLiveCoinUsdCurrency:
		return m.OldLiveCoinUsdCurrency(ctx)
	case payment.FieldCoinInfoID:
		return m.OldCoinInfoID(ctx)
	case payment.FieldState:
		return m.OldState(ctx)
	case payment.FieldChainTransactionID:
		return m.OldChainTransactionID(ctx)
	case payment.FieldPlatformTransactionID:
		return m.OldPlatformTransactionID(ctx)
	case payment.FieldUserSetPaid:
		return m.OldUserSetPaid(ctx)
	case payment.FieldUserSetCanceled:
		return m.OldUserSetCanceled(ctx)
	case payment.FieldUserPaymentTxid:
		return m.OldUserPaymentTxid(ctx)
	case payment.FieldFakePayment:
		return m.OldFakePayment(ctx)
	case payment.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case payment.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case payment.FieldDeleteAt:
		return m.OldDeleteAt(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAppID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case payment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case payment.FieldGoodID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoodID(v)
		return nil
	case payment.FieldOrderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case payment.FieldAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case payment.FieldStartAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAmount(v)
		return nil
	case payment.FieldAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payment.FieldPayWithBalanceAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayWithBalanceAmount(v)
		return nil
	case payment.FieldFinishAmount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishAmount(v)
		return nil
	case payment.FieldCoinUsdCurrency:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinUsdCurrency(v)
		return nil
	case payment.FieldLocalCoinUsdCurrency:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalCoinUsdCurrency(v)
		return nil
	case payment.FieldLiveCoinUsdCurrency:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiveCoinUsdCurrency(v)
		return nil
	case payment.FieldCoinInfoID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoinInfoID(v)
		return nil
	case payment.FieldState:
		v, ok := value.(payment.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case payment.FieldChainTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChainTransactionID(v)
		return nil
	case payment.FieldPlatformTransactionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformTransactionID(v)
		return nil
	case payment.FieldUserSetPaid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSetPaid(v)
		return nil
	case payment.FieldUserSetCanceled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSetCanceled(v)
		return nil
	case payment.FieldUserPaymentTxid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserPaymentTxid(v)
		return nil
	case payment.FieldFakePayment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFakePayment(v)
		return nil
	case payment.FieldCreateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case payment.FieldUpdateAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case payment.FieldDeleteAt:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.addstart_amount != nil {
		fields = append(fields, payment.FieldStartAmount)
	}
	if m.addamount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.addpay_with_balance_amount != nil {
		fields = append(fields, payment.FieldPayWithBalanceAmount)
	}
	if m.addfinish_amount != nil {
		fields = append(fields, payment.FieldFinishAmount)
	}
	if m.addcoin_usd_currency != nil {
		fields = append(fields, payment.FieldCoinUsdCurrency)
	}
	if m.addlocal_coin_usd_currency != nil {
		fields = append(fields, payment.FieldLocalCoinUsdCurrency)
	}
	if m.addlive_coin_usd_currency != nil {
		fields = append(fields, payment.FieldLiveCoinUsdCurrency)
	}
	if m.addcreate_at != nil {
		fields = append(fields, payment.FieldCreateAt)
	}
	if m.addupdate_at != nil {
		fields = append(fields, payment.FieldUpdateAt)
	}
	if m.adddelete_at != nil {
		fields = append(fields, payment.FieldDeleteAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldStartAmount:
		return m.AddedStartAmount()
	case payment.FieldAmount:
		return m.AddedAmount()
	case payment.FieldPayWithBalanceAmount:
		return m.AddedPayWithBalanceAmount()
	case payment.FieldFinishAmount:
		return m.AddedFinishAmount()
	case payment.FieldCoinUsdCurrency:
		return m.AddedCoinUsdCurrency()
	case payment.FieldLocalCoinUsdCurrency:
		return m.AddedLocalCoinUsdCurrency()
	case payment.FieldLiveCoinUsdCurrency:
		return m.AddedLiveCoinUsdCurrency()
	case payment.FieldCreateAt:
		return m.AddedCreateAt()
	case payment.FieldUpdateAt:
		return m.AddedUpdateAt()
	case payment.FieldDeleteAt:
		return m.AddedDeleteAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldStartAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAmount(v)
		return nil
	case payment.FieldAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case payment.FieldPayWithBalanceAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayWithBalanceAmount(v)
		return nil
	case payment.FieldFinishAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinishAmount(v)
		return nil
	case payment.FieldCoinUsdCurrency:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoinUsdCurrency(v)
		return nil
	case payment.FieldLocalCoinUsdCurrency:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLocalCoinUsdCurrency(v)
		return nil
	case payment.FieldLiveCoinUsdCurrency:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLiveCoinUsdCurrency(v)
		return nil
	case payment.FieldCreateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateAt(v)
		return nil
	case payment.FieldUpdateAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdateAt(v)
		return nil
	case payment.FieldDeleteAt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteAt(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(payment.FieldPayWithBalanceAmount) {
		fields = append(fields, payment.FieldPayWithBalanceAmount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	switch name {
	case payment.FieldPayWithBalanceAmount:
		m.ClearPayWithBalanceAmount()
		return nil
	}
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldAppID:
		m.ResetAppID()
		return nil
	case payment.FieldUserID:
		m.ResetUserID()
		return nil
	case payment.FieldGoodID:
		m.ResetGoodID()
		return nil
	case payment.FieldOrderID:
		m.ResetOrderID()
		return nil
	case payment.FieldAccountID:
		m.ResetAccountID()
		return nil
	case payment.FieldStartAmount:
		m.ResetStartAmount()
		return nil
	case payment.FieldAmount:
		m.ResetAmount()
		return nil
	case payment.FieldPayWithBalanceAmount:
		m.ResetPayWithBalanceAmount()
		return nil
	case payment.FieldFinishAmount:
		m.ResetFinishAmount()
		return nil
	case payment.FieldCoinUsdCurrency:
		m.ResetCoinUsdCurrency()
		return nil
	case payment.FieldLocalCoinUsdCurrency:
		m.ResetLocalCoinUsdCurrency()
		return nil
	case payment.FieldLiveCoinUsdCurrency:
		m.ResetLiveCoinUsdCurrency()
		return nil
	case payment.FieldCoinInfoID:
		m.ResetCoinInfoID()
		return nil
	case payment.FieldState:
		m.ResetState()
		return nil
	case payment.FieldChainTransactionID:
		m.ResetChainTransactionID()
		return nil
	case payment.FieldPlatformTransactionID:
		m.ResetPlatformTransactionID()
		return nil
	case payment.FieldUserSetPaid:
		m.ResetUserSetPaid()
		return nil
	case payment.FieldUserSetCanceled:
		m.ResetUserSetCanceled()
		return nil
	case payment.FieldUserPaymentTxid:
		m.ResetUserPaymentTxid()
		return nil
	case payment.FieldFakePayment:
		m.ResetFakePayment()
		return nil
	case payment.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case payment.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case payment.FieldDeleteAt:
		m.ResetDeleteAt()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Payment edge %s", name)
}
